<HTML>
<HEAD>
<TITLE>Mail::Sender - module for sending mails with attachments through an SMTP server</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#constructors">CONSTRUCTORS</A></LI>
	<LI><A HREF="#methods">METHODS</A></LI>
	<LI><A HREF="#config">CONFIG</A></LI>
	<LI><A HREF="#examples">EXAMPLES</A></LI>
	<UL>

		<LI><A HREF="#warning">WARNING</A></LI>
	</UL>

	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#disclaimer">DISCLAIMER</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#copyright">COPYRIGHT</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Mail::Sender - module for sending mails with attachments through an SMTP server</P>
<P>Version 0.7.09</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
 use Mail::Sender;
 $sender = new Mail::Sender
  {smtp =&gt; 'mail.yourdomain.com', from =&gt; 'your@address.com'};
 $sender-&gt;MailFile({to =&gt; 'some@address.com',
  subject =&gt; 'Here is the file',
  msg =&gt; &quot;I'm sending you the list you wanted.&quot;,
  file =&gt; 'filename.txt'});</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><CODE>Mail::Sender</CODE> provides an object oriented interface to sending mails.
It doesn't need any outer program. It connects to a mail server
directly from Perl, using Socket.</P>
<P>Sends mails directly from Perl through a socket connection.</P>
<P>
<HR>
<H1><A NAME="constructors">CONSTRUCTORS</A></H1>
<DL>
<DT><STRONG><A NAME="item_new_Mail%3A%3ASender"><CODE>new Mail::Sender</CODE></A></STRONG><BR>
<DD>
<PRE>
 new Mail::Sender ([from [,replyto [,to [,smtp [,subject [,headers [,boundary]]]]]]])
 new Mail::Sender {[from =&gt; 'somebody@somewhere.com'] , [to =&gt; 'else@nowhere.com'] [...]}</PRE>
<P>Prepares a sender. This doesn't start any connection to the server. You
have to use <CODE>$Sender-</CODE>Open&gt; or <CODE>$Sender-</CODE>OpenMultipart&gt; to start
talking to the server.</P>
<P>The parameters are used in subsequent calls to <CODE>$Sender-</CODE>Open&gt; and
<CODE>$Sender-</CODE>OpenMultipart&gt;. Each such call changes the saved variables.
You can set <CODE>smtp</CODE>,<CODE>from</CODE> and other options here and then use the info
in all messages.</P>
<PRE>
 from      = the senders e-mail address</PRE>
<PRE>
 fake_from = the address that will be shown in headers
             If not specified we use the value of &quot;from&quot;</PRE>
<PRE>
 replyto   = the reply-to address</PRE>
<PRE>
 to        = the recipient's address(es)</PRE>
<PRE>
 fake_to   = the address that will be shown in headers
             If not specified we use the value of &quot;to&quot;</PRE>
<PRE>
 cc        = address(es) to send a copy (carbon copy)</PRE>
<PRE>
 fake_cc   = the address that will be shown in headers
             If not specified we use the value of &quot;cc&quot;</PRE>
<PRE>
 bcc       = address(es) to send a copy (blind carbon copy)
             these addresses will not be visible in the mail!</PRE>
<PRE>
 smtp      = the IP or domain address of your SMTP (mail) server
             This is the name of your LOCAL mail server, do not try to guess
             and contact directly the adressee's mailserver!</PRE>
<PRE>
 subject   = the subject of the message</PRE>
<PRE>
 headers   = the additional headers</PRE>
<PRE>
 boundary  = the message boundary</PRE>
<PRE>
 multipart = the MIME subtype for the whole message (Mixed/Related/Alternative)
  you may need to change this setting if you want to send a HTML body with some
  inline images, or if you want to post the message in plain text as well as
  HTML (alternative). See the examples at the end of the docs.
  You may also use the nickname &quot;subtype&quot;.</PRE>
<PRE>
 type      = the content type of a multipart message, may be usefull for
             multipart/related</PRE>
<PRE>
 ctype     = the content type of a single part message</PRE>
<PRE>
  Please do not confuse these two. The 'type' parameter is used to specify
  the overall content type of a multipart message (for example a HTML document
  with inlined images) while ctype is an ordinary content type for a single
  part message. For example a HTML mail message.</PRE>
<PRE>
 encoding  = encoding of a single part message or the body of a multipart
  message. If the text of the message contains some extended characters or
  very long lines you should use 'encoding =&gt; &quot;Quoted-printable&quot;' in the
  call to Open(), OpenMultipart(), MailMsg() or MailFile().
  Keep in mind that if you use some encoding you should either use SendEnc()
  or encode the data yourself !</PRE>
<PRE>
 charset   = the charset of the message</PRE>
<PRE>
 client     = the name of the client computer. During the connection you send
  the mailserver your name. Usualy a &quot;localhost&quot; is sufficient, but sometimes
  you need to specify some real name. Usualy something like
  `hostname`.'.mycompany.com'. But I leave this for you.
  Mail::Sender doesn't try to guess the name, it sends &quot;localhost&quot; if you do
  not specify otherwise.</PRE>
<PRE>
 priority   = 1 = highest, 2 = high, 3 = normal
  &quot;X-Priority: 1 (Highest)&quot;;</PRE>
<PRE>
 return codes:
  ref to a Mail::Sender object =  success
  -1 = $smtphost unknown
  -2 = socket() failed
  -3 = connect() failed
  -4 = service not available
  -5 = unspecified communication error
  -6 = local user $to unknown on host $smtp
  -7 = transmission of message failed
  -8 = argument $to empty
  -9 = no message specified in call to MailMsg or MailFile
  -10 = no file name specified in call to SendFile or MailFile
  -11 = file not found
  -12 = not available in singlepart mode
   $Mail::Sender::Error contains a textual description of last error.</PRE>
</DL>
<P>
<HR>
<H1><A NAME="methods">METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_Open">Open</A></STRONG><BR>
<DD>
<PRE>
 Open([from [, replyto [, to [, smtp [, subject [, headers]]]]]])
 Open({[from =&gt; &quot;somebody@somewhere.com&quot;] , [to =&gt; &quot;else@nowhere.com&quot;] [...]})</PRE>
<P>Opens a new message. If some parameters are unspecified or empty, it uses
the parameters passed to the ``<CODE>$Sender=new Mail::Sender(...)</CODE>'';</P>
<P>see <A HREF="#item_new_Mail%3A%3ASender"><CODE>new Mail::Sender</CODE></A> for info about the parameters.</P>
<DT><STRONG><A NAME="item_OpenMultipart">OpenMultipart</A></STRONG><BR>
<DD>
<PRE>
 OpenMultipart([from [, replyto [, to [, smtp [, subject [, headers [, boundary]]]]]]])
 OpenMultipart({[from =&gt; &quot;somebody@somewhere.com&quot;] , [to =&gt; &quot;else@nowhere.com&quot;] [...]})</PRE>
<P>Opens a multipart message. If some parameters are unspecified or empty, it uses
the parameters passed to the <CODE>$Sender=new Mail::Sender(...)</CODE>.</P>
<P>see <A HREF="#item_new_Mail%3A%3ASender"><CODE>new Mail::Sender</CODE></A> for info about the parameters.</P>
<DT><STRONG><A NAME="item_MailMsg">MailMsg</A></STRONG><BR>
<DD>
<PRE>
 MailMsg([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message)
 MailMsg({[from =&gt; &quot;somebody@somewhere.com&quot;]
          [, to =&gt; &quot;else@nowhere.com&quot;] [...], msg =&gt; &quot;Message&quot;})</PRE>
<P>Sends a message. If a mail in $sender is opened it gets closed
and a new mail is created and sent. $sender is then closed.
If some parameters are unspecified or empty, it uses
the parameters passed to the ``<CODE>$Sender=new Mail::Sender(...)</CODE>'';</P>
<P>see <A HREF="#item_new_Mail%3A%3ASender"><CODE>new Mail::Sender</CODE></A> for info about the parameters.</P>
<P>The module was made so that you could create an object initialized with
all the necesary options and then send several messages without need to
specify the SMTP server and others each time. If you need to send only
one mail using <A HREF="#item_MailMsg"><CODE>MailMsg()</CODE></A> or <A HREF="#item_MailFile"><CODE>MailFile()</CODE></A> you do not have to create a named
object and then call the method. You may do it like this :</P>
<PRE>
 (new Mail::Sender)-&gt;MailMsg({smtp =&gt; 'mail.company.com', ...});</PRE>
<DT><STRONG><A NAME="item_MailFile">MailFile</A></STRONG><BR>
<DD>
<PRE>
 MailFile([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message, file(s))
 MailFile({[from =&gt; &quot;somebody@somewhere.com&quot;]
           [, to =&gt; &quot;else@nowhere.com&quot;] [...],
           msg =&gt; &quot;Message&quot;, file =&gt; &quot;File&quot;})</PRE>
<P>Sends one or more files by mail. If a mail in $sender is opened it gets closed
and a new mail is created and sent. $sender is then closed.
If some parameters are unspecified or empty, it uses
the parameters passed to the ``<CODE>$Sender=new Mail::Sender(...)</CODE>'';</P>
<P>The <A HREF="#item_file"><CODE>file</CODE></A> parameter may be a ``filename'', a ``list, of, file, names'' or a \@list of file names.</P>
<P>see <A HREF="#item_new_Mail%3A%3ASender"><CODE>new Mail::Sender</CODE></A> for info about the parameters.</P>
<P>Just keep in mind that parameters like ctype, charset and encoding
will be used for the attached file, not the body of the message.
If you want to specify those parameters for the body you have to use
b_ctype, b_charset and b_encoding. Sorry.</P>
<DT><STRONG><A NAME="item_Send">Send</A></STRONG><BR>
<DD>
<PRE>
 Send(@strings)</PRE>
<P>Prints the strings to the socket. Doesn't add any end-of-line characters.
You should use <CODE>\r\n</CODE> as the end-of-line. IF YOU ARE NOT SURE ABOUT THIS USE <A HREF="#item_SendEx"><CODE>SendEx()</CODE></A> INSTEAD!</P>
<DT><STRONG><A NAME="item_SendLine">SendLine</A></STRONG><BR>
<DD>
<PRE>
 SendLine(@strings)</PRE>
<P>Prints the strings to the socket. Adds the end-of-line character at the end.</P>
<DT><STRONG><A NAME="item_SendEnc">SendEnc</A></STRONG><BR>
<DD>
<PRE>
 SendEnc(@strings)</PRE>
<P>Prints the strings to the socket. Doesn't add any end-of-line characters.
You should use <CODE>\r\n</CODE> as the end-of-line.
Encodes the text using the selected encoding (Base64/Quoted-printable)</P>
<DT><STRONG><A NAME="item_SendLineEnc">SendLineEnc</A></STRONG><BR>
<DD>
<PRE>
 SendLineEnc(@strings)</PRE>
<P>Prints the strings to the socket. Add the end-of-line character at the end.
Encodes the text using the selected encoding (Base64/Quoted-printable)</P>
<P>Do NOT mix up Send[Line][Ex] and Send[Line]Enc! SendEnc does some buffering
necessary for correct Base64 encoding, and Send is not aware of that!</P>
<P>Usage of Send[Line][Ex] in non 7BIT parts not recommended.
Using <A HREF="#item_Send"><CODE>Send(encode_base64($string))</CODE></A> may, but may NOT work!
In particular if you use several such to create one part,
the data is very likely to get crippled.</P>
<DT><STRONG><A NAME="item_SendEx">SendEx</A></STRONG><BR>
<DD>
<PRE>
 SendEx(@strings)</PRE>
<P>Prints the strings to the socket. Doesn't add any end-of-line characters.
Changes all end-of-lines to <CODE>\r\n</CODE>. YOU'D BETTER USE THIS METHOD THAN JUST Send(),
SOME E-MAIL SERVERS ARE PICKY AND WOUNT ACCEPT THE MESSAGE IF YOU DO NOT USE CRLF (\r\n)
AS THE END-OF-LINE !</P>
<DT><STRONG><A NAME="item_SendLineEx">SendLineEx</A></STRONG><BR>
<DD>
<PRE>
 SendLineEx(@strings)</PRE>
<P>Prints the strings to the socket. Adds an end-of-line character at the end.
Changes all end-of-lines to <CODE>\r\n</CODE>.</P>
<DT><STRONG><A NAME="item_Part">Part</A></STRONG><BR>
<DD>
<PRE>
 Part( I&lt;description&gt;, I&lt;ctype&gt;, I&lt;encoding&gt;, I&lt;disposition&gt; [, I&lt;content_id&gt;]);
 Part( [description =&gt; &quot;desc&quot;], [ctype], [encoding], [disposition], [content_id]});</PRE>
<PRE>
 Prints a part header for the multipart message.
 The undef or empty variables are ignored.</PRE>
<DL>
<DT><STRONG><A NAME="item_description">description</A></STRONG><BR>
<DD>
The title for this part.
<P></P>
<DT><STRONG><A NAME="item_ctype">ctype</A></STRONG><BR>
<DD>
the content type (MIME type) of this part. May contain some other
parameters, such as <STRONG>charset</STRONG> or <STRONG>name</STRONG>.
<P>Defaults to ``application/octet-stream''.</P>
<P></P>
<DT><STRONG><A NAME="item_encoding">encoding</A></STRONG><BR>
<DD>
the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT
...
<P>Defaults to ``7BIT''.</P>
<P></P>
<DT><STRONG><A NAME="item_disposition">disposition</A></STRONG><BR>
<DD>
This parts disposition. Eg: 'attachment; filename=``send.pl'''.
<P>Defaults to ``attachment''. If you specify ``none'' or ``'', the
Content-disposition: line will not be included in the headers.</P>
<P></P>
<DT><STRONG><A NAME="item_content_id">content_id</A></STRONG><BR>
<DD>
The content id of the part, used in multipart/related.
If not specified, the header is not included.
<P></P></DL>
<DT><STRONG><A NAME="item_Body">Body</A></STRONG><BR>
<DD>
<PRE>
 Body([charset [, encoding [, content-type]]]);</PRE>
<P>Sends the head of the multipart message body. You can specify the
charset and the encoding. Default is ``US-ASCII'',``7BIT'','text/plain'.</P>
<P>If you pass undef or zero as the parameter, this function uses the default
value:</P>
<PRE>
    Body(0,0,'text/html');</PRE>
<DT><STRONG><A NAME="item_SendFile">SendFile</A></STRONG><BR>
<DD>
<PRE>
 SendFile( I&lt;description&gt;, I&lt;ctype&gt;, I&lt;encoding&gt;, I&lt;disposition&gt;, I&lt;file&gt;);
 SendFile( { [description =&gt; &quot;desc&quot;] , [ctype =&gt; &quot;ctype&quot;], [encoding =&gt; &quot;encoding&quot;],
             [disposition =&gt; &quot;disposition&quot;], file =&gt; &quot;file&quot;});</PRE>
<PRE>
 Sends a file as a separate part of the mail message. Only in multipart mode.</PRE>
<DL>
<DT><STRONG>description</STRONG><BR>
<DD>
The title for this part.
<P></P>
<DT><STRONG>ctype</STRONG><BR>
<DD>
the content type (MIME type) of this part. May contain some other
parameters, such as <STRONG>charset</STRONG> or <STRONG>name</STRONG>.
<P>Defaults to ``application/octet-stream''.</P>
<P></P>
<DT><STRONG>encoding</STRONG><BR>
<DD>
the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT
...
<P>Defaults to ``Base64''.</P>
<P></P>
<DT><STRONG>disposition</STRONG><BR>
<DD>
This parts disposition. Eg: 'attachment; filename=``send.pl'''. If you use
'attachment; filename=*' the * will be replaced by the respective names
of the sent files.
<P>Defaults to ``attachment; filename=*''. If you do not want to include this header use
``'' as the value.</P>
<P></P>
<DT><STRONG><A NAME="item_file">file</A></STRONG><BR>
<DD>
The name of the file to send or a 'list, of, names' or a
['reference','to','a','list','of','filenames']. Each file will be sent as
a separate part.
<P></P>
<DT><STRONG>content_id</STRONG><BR>
<DD>
The content id of the message part. Used in multipart/related.
<PRE>
 Special values:
  &quot;*&quot; =&gt; the name of the file
  &quot;#&quot; =&gt; autoincremented number (starting from 0)</PRE>
<P></P></DL>
<DT><STRONG><A NAME="item_Close">Close</A></STRONG><BR>
<DD>
<PRE>
 $sender-&gt;Close;</PRE>
<P>Close and send the mail. This method should be called automatically when destructing
the object, but you should call it yourself just to be sure it gets called.
And you should do it as soon as possible to close the connection and free the socket.</P>
<P>The mail is being sent to server, but is not processed by the server
till the sender object is closed!</P>
<DT><STRONG><A NAME="item_Cancel">Cancel</A></STRONG><BR>
<DD>
<PRE>
 $sender-&gt;Cancel;</PRE>
<P>Cancel an opened message.</P>
<P>SendFile and other methods may set $sender-&gt;{'error'}.
In that case ``undef $sender'' calls <CODE>$sender-</CODE>&gt;Cancel not <CODE>$sender-</CODE>&gt;Close!!!</P>
<DT><STRONG><A NAME="item_%40Mail%3A%3ASender%3A%3AErrors">@Mail::Sender::Errors</A></STRONG><BR>
<DD>
Contains the description of errors returned by functions in Mail::Sender.
<P>Usage: @Mail::Sender::Errors[$sender-&gt;{error}]</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="config">CONFIG</A></H1>
<P>If you create a file named Sender.config in the same directory where
Sender.pm resides, this file will be ``require''d as soon as you ``use
Mail::Sender'' in your script. Of course the Sender.config MUST ``return a
true value'', that is it has to be succesfully compiled and the last
statement must return a true value. You may use this to forbide the use
of Mail::Sender to some users.</P>
<P>You may define the default settings for new Mail::Sender objects and do
a few more things.</P>
<P>The default options are stored in hash %Mail::Sender::default. You may
use all the examples you'd use in <CODE>new</CODE>, <A HREF="#item_Open"><CODE>Open</CODE></A>, <A HREF="#item_OpenMultipart"><CODE>OpenMultipart</CODE></A>,
<A HREF="#item_MailMsg"><CODE>MailMsg</CODE></A> or <A HREF="#item_MailFile"><CODE>MailFile</CODE></A>.</P>
<PRE>
 Eg.
  %default = (
    smtp =&gt; 'mail.mccann.cz',
    from =&gt; Win32::LoginName.'@mccann.cz',
    client =&gt; Win32::NodeName.'mccann.cz'
  );
  # of course you will use your own mail server here !</PRE>
<P>The other options you may set here (or later of course) are
$Mail::Sender::SITE_HEADERS and $Mail::Sender::NO_X_MAILER.</P>
<P>The $Mail::Sender::SITE_HEADERS may contain headers that will be added
to each mail message sent by this script, the $Mail::Sender::NO_X_MAILER
disables the header item specifying that the message was sent by
Mail::Sender.</P>
<P>!!! $Mail::Sender::SITE_HEADERS may NEVER end with \r\n !!!</P>
<P>If you want to set the $Mail::Sender::SITE_HEADERS for every script sent
from your server without your users being able to change it you may use
this hack:</P>
<PRE>
 $loginname = something_that_identifies_the_user();
 *Mail::Sender::SITE_HEADERS = \&quot;X-Sender: $loginname via $0&quot;;</PRE>
<P>You may even ``install'' your custom function that will be evaluated for
each message just before contacting the server. You may change all the
options from within as well as stop sending the message.</P>
<P>All you have to do is to create a function named SiteHook in
Mail::Sender package. This function will get the Mail::Sender object as
its first argument. If it returns a TRUE value the message is sent,
if it returns FALSE the sending is canceled and the user gets
``Site specific error'' error message.</P>
<P>If you want to give some better error message you may do it like this :</P>
<PRE>
 sub SiteHook {
  my $self = shift;
  if (whatever($self)) {
    $self-&gt;{'error'} = SITEERROR;
    $Mail::Sender::Error = &quot;I don't like this mail&quot;;
    return 0
  } else {
    return 1;
  }
 }</PRE>
<P>This example will ensure the from address is the users real address :</P>
<PRE>
 sub SiteHook {
  my $self = shift;
  $self-&gt;{fromaddr} = getlogin.'@yoursite.com';
  $self-&gt;{from} = getlogin.'@yoursite.com';
  1;
 }</PRE>
<P>Please note that at this stage the from address is in two different 
object properties.</P>
<P>$self-&gt;{from} is the address as it will appear in the mail, that is 
it may include the full name of the user or any other comment
( ``Jan Krynicky &lt;<A HREF="mailto:jenda@krynicky.cz">jenda@krynicky.cz</A>&gt;'' for example), while the 
$self-&gt;{fromaddr} is realy just the email address per se and it will 
be used in conversation with the SMTP server. It must be without 
comments <A HREF="mailto:(``jenda@krynicky.cz''">(``jenda@krynicky.cz''</A> for example)!</P>
<P>Without write access to .../lib/Mail/Sender.pm or
.../lib/Mail/Sender.config your users will then be unable to get rid of
this header. Well ... everything is doable, if he's cheeky enough ... :-(</P>
<P>So if you take care of some site with virtual servers for several
clients and implement some policy via <CODE>SiteHook()</CODE> or
$Mail::Sender::SITE_HEADERS search the clients' scripts for ``SiteHook''
and ``SITE_HEADERS'' from time to time. To see who's cheating.</P>
<P>
<HR>
<H1><A NAME="examples">EXAMPLES</A></H1>
<PRE>
 use Mail::Sender;</PRE>
<PRE>
 #$sender = new Mail::Sender { from =&gt; 'somebody@somewhere.com',
    smtp =&gt; 'ms.chipnet.cz', boundary =&gt; 'This-is-a-mail-boundary-435427'};
 # # if you do not care about errors.
 # # otherwise use
 #
 ref ($sender = new Mail::Sender { from =&gt; 'somebody@somewhere.com',
       smtp =&gt; 'ms.chipnet.cz', boundary =&gt; 'This-is-a-mail-boundary-435427'})
 or die &quot;Error($sender) : $Mail::Sender::Error\n&quot;;</PRE>
<PRE>
 $sender-&gt;Open({to =&gt; 'friend@other.com', subject =&gt; 'Hello dear friend'});
 $sender-&gt;SendLine(&quot;How are you?&quot;);
 $sender-&gt;SendLine;
 $sender-&gt;Send(&lt;&lt;'*END*');
 I've found these jokes.</PRE>
<PRE>
  Doctor, I feel like a pack of cards.
  Sit down and I'll deal with you later.</PRE>
<PRE>
  Doctor, I keep thinking I'm a dustbin.
  Don't talk rubbish.</PRE>
<PRE>
 Hope you like'em. Jenda
 *END*</PRE>
<PRE>
 $sender-&gt;Close;</PRE>
<PRE>
 $sender-&gt;Open({to =&gt; 'mama@home.org, papa@work.com',
                cc =&gt; 'somebody@somewhere.com',
                subject =&gt; 'Sorry, I'll come later.'});
 $sender-&gt;SendLine(&quot;I'm sorry, but due to a big load of work,
    I'll come at 10pm at best.&quot;);
 $sender-&gt;SendLine(&quot;\nHi, Jenda&quot;);</PRE>
<PRE>
 $sender-&gt;Close;</PRE>
<PRE>
 $sender-&gt;OpenMultipart({to =&gt; 'Perl-Win32-Users@activeware.foo',
                         subject =&gt; 'Mail::Sender.pm - new module'});
 $sender-&gt;Body;
 $sender-&gt;Send(&lt;&lt;'*END*');
 Here is a new module Mail::Sender.
 It provides an object based interface to sending SMTP mails.
 It uses a direct socket connection, so it doesn't need any
 additional program.</PRE>
<PRE>
 Enjoy, Jenda
 *END*
 $sender-&gt;SendFile(
  {description =&gt; 'Perl module Mail::Sender.pm',
   ctype =&gt; 'application/x-zip-encoded',
   encoding =&gt; 'Base64',
   disposition =&gt; 'attachment; filename=&quot;Sender.zip&quot;; type=&quot;ZIP archive&quot;',
   file =&gt; 'sender.zip'
  });
 $sender-&gt;Close;</PRE>
<PRE>
 _END_</PRE>
<P>If everything you need is to send a simple message you may use:</P>
<PRE>
 use Mail::Sender;</PRE>
<PRE>
 ref ($sender = new Mail::Sender({from =&gt; 'somebody@somewhere.com',smtp
 =&gt; 'ms.chipnet.cz'})) or die &quot;$Mail::Sender::Error\n&quot;;</PRE>
<PRE>
 (ref ($sender-&gt;MailMsg({to =&gt;'Jenda@Krynicky.czX', subject =&gt; 'this is a test',
                         msg =&gt; &quot;Hi Johnie.\nHow are you?&quot;}))
  and print &quot;Mail sent OK.&quot;
 )
 or die &quot;$Mail::Sender::Error\n&quot;;
 __END__</PRE>
<P>If you want to attach some files:</P>
<PRE>
 use Mail::Sender;</PRE>
<PRE>
 ref ($sender = new Mail::Sender({from =&gt; 'somebody@somewhere.com',smtp
 =&gt; 'mail.yourdomain.com'})) or die &quot;$Mail::Sender::Error\n&quot;;</PRE>
<PRE>
 (ref ($sender-&gt;MailFile(
  {to =&gt;'you@address.com', subject =&gt; 'this is a test',
   msg =&gt; &quot;Hi Johnie.\nI'm sending you the pictures you wanted.&quot;,
   file =&gt; 'image1.jpg,image2.jpg'
  }))
  and print &quot;Mail sent OK.&quot;
 )
 or die &quot;$Mail::Sender::Error\n&quot;;
 __END__</PRE>
<P>If you want to send a HTML mail:</P>
<PRE>
 use Mail::Sender;
 open IN, $htmlfile or die &quot;Cannot open $htmlfile : $!\n&quot;;
 $sender = new Mail::Sender {smtp =&gt; 'mail.yourdomain.com'};
 $sender-&gt;Open({ from =&gt; 'your@address.com', to =&gt; 'other@address.com', subject =&gt; 'HTML test',
        headers =&gt; &quot;MIME-Version: 1.0\r\nContent-type: text/html\r\nContent-Transfer-Encoding: 7bit&quot;
 }) or die $Mail::Sender::Error,&quot;\n&quot;;</PRE>
<PRE>
 while (&lt;IN&gt;) { $sender-&gt;Send($_) };
 close IN;
 $sender-&gt;Close();
 __END__</PRE>
<P>If you want to send a HTML with some inline images :</P>
<PRE>
 use strict;
 use Mail::Sender;
 my $recipients = 'somebody@somewhere.com';
 my $sender = new Mail::Sender {smtp =&gt; 'your.mailhost.com'};
 if ($sender-&gt;OpenMultipart({from =&gt; 'itstech2@gate.net', to =&gt; $recipients,
                       subject =&gt; 'Embedded Image Test', subtype =&gt; 'related',
                       boundary =&gt; 'boundary-test-1',
                       type =&gt; 'multipart/related'}) &gt; 0) {
  $sender-&gt;SendFile(
         {description =&gt; 'html body',
         ctype =&gt; 'text/html; charset=us-ascii',
         encoding =&gt; '7bit',
         disposition =&gt; 'NONE',
         file =&gt; 'test.html'
   });
  $sender-&gt;SendFile(
   {description =&gt; 'ed\'s gif',
    ctype =&gt; 'image/gif',
    encoding =&gt; 'base64',
    disposition =&gt; &quot;inline; filename=\&quot;apache_pb.gif\&quot;;\r\nContent-ID: &lt;ed1&gt;&quot;,
    file =&gt; 'apache_pb.gif'
   });
  $sender-&gt;Close() or die &quot;Close failed! $Mail::Sender::Error\n&quot;;
 } else {
  die &quot;Cannot send mail: $Mail::Sender::Error\n&quot;;
 }
 __END__</PRE>
<P>In the HTML you'll have this :
 ... &lt;IMG src=``cid:ed1''&gt; ...</P>
<P>Please keep in mind that the image name is unimportant, the Content-ID is what counts!</P>
<P>If you want to send a mail with an attached file you just got from a HTML form:</P>
<PRE>
 #!perl</PRE>
<PRE>
 use CGI;
 use Mail::Sender;</PRE>
<PRE>
 $query = new CGI;</PRE>
<PRE>
 # uploading the file...
 $filename = $query-&gt;param('mailformFile');
 if ($filename ne &quot;&quot;){
  $tmp_file = $query-&gt;tmpFileName($filename);
 }</PRE>
<PRE>
 $sender = new Mail::Sender {from =&gt; 'script@krynicky.cz',smtp =&gt; 'mail.krynicky.czX'};
 $sender-&gt;OpenMultipart({to=&gt; 'jenda@krynicky.czX',subject=&gt; 'test CGI attach'});
 $sender-&gt;Body();
 $sender-&gt;Send(&lt;&lt;&quot;*END*&quot;);
 This is just a test of mail with an uploaded file.</PRE>
<PRE>
 Jenda
 *END*
 $sender-&gt;SendFile(
          {encoding =&gt; 'Base64',
    description =&gt; $filename,
    ctype =&gt; $query-&gt;uploadInfo($filename)-&gt;{'Content-Type'},
    disposition =&gt; &quot;attachment; filename = $filename&quot;,
           file =&gt; $tmp_file
          });
 $sender-&gt;Close();</PRE>
<PRE>
 print &quot;Content-type: text/plain\n\nYes, it's sent\n\n&quot;;</PRE>
<P>If you want to confirm reading you add :</P>
<PRE>
        headers =&gt; &quot;X-Confirm-Reading-To: $from_address&quot;</PRE>
<P>if you want delivery report you add :</P>
<PRE>
        headers =&gt; &quot;Return-receipt-to: $from_address&quot;</PRE>
<P>if both :</P>
<PRE>
        headers =&gt; &quot;X-Confirm-Reading-To: $from_address\nReturn-receipt-to: $from_address&quot;</PRE>
<P>
<H2><A NAME="warning">WARNING</A></H2>
<P>DO NOT mix Open(Multipart)|Send(Line)(Ex)|Close with MailMsg or MailFile.
Both <CODE>Mail(Msg/File)</CODE> close any Open-ed mail.
Do not try this:</P>
<PRE>
 $sender = new Mail::Sender ...;
 $sender-&gt;OpenMultipart...;
 $sender-&gt;Body;
 $sender-&gt;Send(&quot;...&quot;);
 $sender-&gt;MailFile({file =&gt; 'something.ext');
 $sender-&gt;Close;</PRE>
<P>This WON'T work!!!</P>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>This module (as well as those I used as an example when I wrote it) doesn't work with qmail.
To make this clear, the local SMTP server you contact directly from the script
(Open({smtp =&gt; ...})) may not be qmail. The problem is that the module expects a one-line
response from the server and gets confused if it gets a longer response.
If you set up qmail to send only one-line responses you shell be OK.
Otherwise you need to use a different SMTP server. Sorry, I'll fix this as soon as I have
some spare time.</P>
<P>
<HR>
<H1><A NAME="disclaimer">DISCLAIMER</A></H1>
<P>This module is based on SendMail.pm Version : 1.21 that appeared in
<A HREF="mailto:Perl-Win32-Users@activeware.com">Perl-Win32-Users@activeware.com</A> mailing list. I don't remember the name
of the poster and it's not mentioned in the script. Thank you mr. <CODE>undef</CODE>.</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Jan Krynicky &lt;<A HREF="mailto:Jenda@Krynicky.cz">Jenda@Krynicky.cz</A>&gt; 
<A HREF="http://Jenda.Krynicky.cz">http://Jenda.Krynicky.cz</A></P>
<P>With help of Rodrigo Siqueira &lt;<A HREF="mailto:rodrigo@insite.com.br">rodrigo@insite.com.br</A>&gt;, Ed McGuigan &lt;<A HREF="mailto:itstech1@gate.net">itstech1@gate.net</A>&gt;, and others.</P>
<P>
<HR>
<H1><A NAME="copyright">COPYRIGHT</A></H1>
<P>Copyright (c) 1997-2001 Jan Krynicky &lt;<A HREF="mailto:Jenda@Krynicky.cz">Jenda@Krynicky.cz</A>&gt;. All rights reserved.</P>
<P>This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. There is only one aditional condition, you may 
NOT use this module for SPAMing! NEVER! (see <A HREF="http://spam.abuse.net/">http://spam.abuse.net/</A> for definition)</P>

</BODY>

</HTML>
